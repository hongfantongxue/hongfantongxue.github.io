<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  
  
  
  <meta name="description" content="记录技术点滴">
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <title>
    Flink基础-Window&amp;Watermark |
    
    个人博客</title>
  
  <link rel="shortcut icon" href="/favicon.ico">
  
  
<link rel="stylesheet" href="/css/style.css">

  
  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<script src="/js/pace.min.js"></script>

<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <main class="content">
    <section class="outer">
  <article id="post-Flink基础-Window-Watermark" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
      

<h1 class="article-title" itemprop="name">
  Flink基础-Window&amp;Watermark
</h1>



    </header>
    

    
    <div class="article-meta">
      <a href="/2020/01/01/Flink%E5%9F%BA%E7%A1%80-Window-Watermark/" class="article-date">
  <time datetime="2019-12-31T17:00:00.000Z" itemprop="datePublished">2020-01-01</time>
</a>
      
    </div>
    

    
    
<div class="tocbot"></div>

    

    <div class="article-entry" itemprop="articleBody">
      
      
      
      <h4 id="1-1-Flink-Window操作"><a href="#1-1-Flink-Window操作" class="headerlink" title="1.1.Flink Window操作"></a>1.1.Flink Window操作</h4><p>Flink任务Batch是Streaming的一个特例，因此Flink底层引擎是一个流式引擎，在上面实现了流处理和批处理。而Window就是从Streaming到Batch的桥梁</p>
<p>Window窗口就在一个无界流中设置起始位置和终止位置，让无界流变成有界流，并且在有界流中进行数据处理</p>
<p>Window操作常见的业务场景：统计过去一段时间、最近一些元素的数据指标</p>
<h4 id="1-2-Window窗口分类"><a href="#1-2-Window窗口分类" class="headerlink" title="1.2.Window窗口分类"></a>1.2.Window窗口分类</h4><p>Window窗口在无界流中设置起始位置和终止位置的方式可以有两种：</p>
<ul>
<li>根据时间设置</li>
<li>根据窗口数据量（count）设置</li>
</ul>
<p>根据窗口的类型划分：</p>
<ul>
<li>滚动窗口</li>
<li>滑动窗口</li>
</ul>
<p>根据数据流类型划分：</p>
<ul>
<li>Keyed Window：基于分组后的数据流之上做窗口操作</li>
<li>Global Window：基于未分组的数据流之上做窗口操作</li>
</ul>
<p>根据不同的组合方式，可以组合出来8种窗口类型：</p>
<ol>
<li><p>基于分组后的数据流上的时间滚动窗口</p>
</li>
<li><p>基于分组后的数据流上的时间滑动窗口</p>
</li>
<li><p>基于分组后的数据流上的count滚动窗口</p>
</li>
<li><p>基于分组后的数据流上的count滑动窗口</p>
</li>
<li><p>基于未分组的数据流上的时间滚动窗口</p>
</li>
<li><p>基于未分组的数据流上的时间滑动窗口</p>
</li>
<li><p>基于未分组的数据流上的count滚动窗口</p>
</li>
<li><p>基于未分组的数据流上的count滑动窗口</p>
</li>
</ol>
<p>当然我们也可以根据实际业务场景自定义Window，这就是Flink最大的优势：Window种类多，灵活</p>
<p>Time Window（基于时间的窗口）</p>
<p>Tumbling Window：滚动窗口，窗口之间没有数据重叠</p>
<p><img src="/img/image-20211025110303877.png" alt="image-20211025110303877"></p>
<p>Sliding Window：滑动窗口，窗口内的数据有重叠</p>
<p>在定义滑动窗口的时候，不只是要定义窗口大小，还要定义窗口的滑动间隔时间（每隔多久</p>
<p>滑动一次），如果滑动间隔时间=窗口大小=滚动窗口</p>
<p><img src="/img%5Cimage-20211025110356614.png" alt="image-20211025110356614"></p>
<p>另外还有会话窗口Session Window，此种一般不用</p>
<p><img src="/img%5Cimage-20211025172052343.png" alt="image-20211025172052343"></p>
<h4 id="1-3-窗口聚合函数"><a href="#1-3-窗口聚合函数" class="headerlink" title="1.3.窗口聚合函数"></a>1.3.窗口聚合函数</h4><p>窗口函数定义了针对窗口内元素的计算逻辑，窗口函数大概分为两类：</p>
<ol>
<li>增量聚合函数，聚合原理：窗口内保存一个中间聚合结果，随着新元素的加入，不断对该值进行更新</li>
</ol>
<p>​    这类函数通常非常节省空间 ReduceFunction、AggregateFunction属于增量聚合函数</p>
<ol start="2">
<li>全量聚合函数，聚合原理：收集窗口内的所有元素，并且在执行的时候对他们进行遍历，这种聚合函数通常需要占用更多的空间（收集一段时间的数据并且保存），但是它可以支持更复杂的逻辑ProcessWindowFunction、WindowFunction属于全量窗口函数</li>
</ol>
<p>注意：这两类函数可以组合搭配使用</p>
<h5 id="1-3-1-增量聚合函数"><a href="#1-3-1-增量聚合函数" class="headerlink" title="1.3.1.增量聚合函数"></a>1.3.1.增量聚合函数</h5><h6 id="案例一-使用增量聚合函数统计最近5s内，各个卡口的车流量"><a href="#案例一-使用增量聚合函数统计最近5s内，各个卡口的车流量" class="headerlink" title="案例一:使用增量聚合函数统计最近5s内，各个卡口的车流量"></a>案例一:使用增量聚合函数统计最近5s内，各个卡口的车流量</h6><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xyz.window</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.lang3.<span class="type">StringUtils</span></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.common.functions.<span class="type">AggregateFunction</span></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.common.serialization.<span class="type">SimpleStringSchema</span></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.scala.<span class="type">StreamExecutionEnvironment</span></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.scala._</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.scala.function.&#123;<span class="type">ProcessWindowFunction</span>, <span class="type">WindowFunction</span>&#125;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.windowing.assigners.<span class="type">TumblingProcessingTimeWindows</span></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.windowing.time.<span class="type">Time</span></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.windowing.windows.<span class="type">TimeWindow</span></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.connectors.kafka.<span class="type">FlinkKafkaConsumer</span></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.util.<span class="type">Collector</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.<span class="type">Properties</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用增量聚合函数统计最近5s内，各个卡口的车流量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">StatisCarFlow</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> env = <span class="type">StreamExecutionEnvironment</span>.getExecutionEnvironment</span><br><span class="line">    <span class="keyword">val</span> props = <span class="keyword">new</span> <span class="type">Properties</span>()</span><br><span class="line">    props.setProperty(<span class="string">&quot;bootstrap.servers&quot;</span>, <span class="string">&quot;hadoop001:9092&quot;</span>)</span><br><span class="line">    props.setProperty(<span class="string">&quot;group.id&quot;</span>, <span class="string">&quot;StatisCarFlow&quot;</span>)</span><br><span class="line">    env.addSource(<span class="keyword">new</span> <span class="type">FlinkKafkaConsumer</span>[<span class="type">String</span>](<span class="string">&quot;traffic_info&quot;</span>, <span class="keyword">new</span> <span class="type">SimpleStringSchema</span>(), props).setStartFromEarliest())</span><br><span class="line">      .filter(line =&gt; <span class="type">StringUtils</span>.isNotEmpty(line) &amp;&amp; !line.equals(<span class="string">&quot;None&quot;</span>))</span><br><span class="line">      .map(line =&gt; &#123;</span><br><span class="line">        <span class="keyword">val</span> strings = line.split(<span class="string">&quot;,&quot;</span>)</span><br><span class="line">        (strings(<span class="number">1</span>), <span class="number">1</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      ).keyBy(_._1).window(<span class="type">TumblingProcessingTimeWindows</span>.of(<span class="type">Time</span>.seconds(<span class="number">5</span>)))</span><br><span class="line">      .aggregate(<span class="keyword">new</span> <span class="type">AggregateFunction</span>[(<span class="type">String</span>, <span class="type">Int</span>), <span class="type">Int</span>, <span class="type">Int</span>]() &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">createAccumulator</span></span>(): <span class="type">Int</span> = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">add</span></span>(value: (<span class="type">String</span>, <span class="type">Int</span>), accumulator: <span class="type">Int</span>): <span class="type">Int</span> = accumulator + value._2</span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">getResult</span></span>(accumulator: <span class="type">Int</span>): <span class="type">Int</span> = accumulator</span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">merge</span></span>(a: <span class="type">Int</span>, b: <span class="type">Int</span>): <span class="type">Int</span> = a + b</span><br><span class="line">      &#125;,</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * ProcessWindowFunction、WindowFunction区别在于ProcessWindowFunction可以获取Flink执行的</span></span><br><span class="line"><span class="comment">         * 上下文，可以拿到当前的数据更多信息，比如窗口状态、窗口起始与终止时间、当前水印、时间戳等</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//        new WindowFunction[Int, (String, Int), String, TimeWindow] &#123;</span></span><br><span class="line">        <span class="comment">//          override def apply(key: String, window: TimeWindow, input: Iterable[Int], out: Collector[(String, Int)]): Unit = &#123;</span></span><br><span class="line">        <span class="comment">//            for (elem &lt;- input) &#123;</span></span><br><span class="line">        <span class="comment">//               out.collect((key, elem))</span></span><br><span class="line">        <span class="comment">//            &#125;</span></span><br><span class="line">        <span class="comment">//          &#125;</span></span><br><span class="line">        <span class="comment">//        &#125;</span></span><br><span class="line">        <span class="keyword">new</span> <span class="type">ProcessWindowFunction</span>[<span class="type">Int</span>, (<span class="type">String</span>, <span class="type">Int</span>), <span class="type">String</span>, <span class="type">TimeWindow</span>] &#123;</span><br><span class="line">          <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">process</span></span>(key: <span class="type">String</span>, context: <span class="type">Context</span>, elements: <span class="type">Iterable</span>[<span class="type">Int</span>], out: <span class="type">Collector</span>[(<span class="type">String</span>, <span class="type">Int</span>)]): <span class="type">Unit</span> = &#123;</span><br><span class="line">            <span class="keyword">for</span> (elem &lt;- elements) &#123;</span><br><span class="line">              out.collect((key, elem))</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ).print()</span><br><span class="line">    env.execute(<span class="type">StatisCarFlow</span>.getClass.getName)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="案例二-每隔10s统计每辆汽车的平均速度"><a href="#案例二-每隔10s统计每辆汽车的平均速度" class="headerlink" title="案例二:每隔10s统计每辆汽车的平均速度"></a>案例二:每隔10s统计每辆汽车的平均速度</h6><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xyz.window</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.lang3.<span class="type">StringUtils</span></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.common.functions.<span class="type">AggregateFunction</span></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.common.serialization.<span class="type">SimpleStringSchema</span></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.scala.<span class="type">StreamExecutionEnvironment</span></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.scala._</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.scala.function.<span class="type">ProcessWindowFunction</span></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.windowing.assigners.<span class="type">TumblingProcessingTimeWindows</span></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.windowing.time.<span class="type">Time</span></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.connectors.kafka.<span class="type">FlinkKafkaConsumer</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.<span class="type">Properties</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 每隔10s统计每辆汽车的平均速度</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Demo02SpeedAVG</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> env = <span class="type">StreamExecutionEnvironment</span>.getExecutionEnvironment</span><br><span class="line">    <span class="keyword">val</span> props = <span class="keyword">new</span> <span class="type">Properties</span>()</span><br><span class="line">    props.setProperty(<span class="string">&quot;bootstrap.servers&quot;</span>, <span class="string">&quot;hadoop001:9092&quot;</span>)</span><br><span class="line">    props.setProperty(<span class="string">&quot;group.id&quot;</span>, <span class="string">&quot;StatisCarFlow&quot;</span>)</span><br><span class="line">    env.addSource(<span class="keyword">new</span> <span class="type">FlinkKafkaConsumer</span>[<span class="type">String</span>](<span class="string">&quot;traffic_info&quot;</span>, <span class="keyword">new</span> <span class="type">SimpleStringSchema</span>(), props).setStartFromEarliest())</span><br><span class="line">      .filter(line =&gt; <span class="type">StringUtils</span>.isNotEmpty(line) &amp;&amp; !line.equals(<span class="string">&quot;None&quot;</span>))</span><br><span class="line">      .map(line =&gt; &#123;</span><br><span class="line">        <span class="keyword">val</span> strings = line.split(<span class="string">&quot;,&quot;</span>)</span><br><span class="line">        (strings(<span class="number">3</span>), strings(<span class="number">4</span>).toDouble)</span><br><span class="line">      &#125;</span><br><span class="line">      ).keyBy(_._1).window(<span class="type">TumblingProcessingTimeWindows</span>.of(<span class="type">Time</span>.seconds(<span class="number">10</span>)))</span><br><span class="line">      .aggregate(<span class="keyword">new</span> <span class="type">AggregateFunction</span>[(<span class="type">String</span>, <span class="type">Double</span>), (<span class="type">String</span>, <span class="type">Double</span>, <span class="type">Int</span>), (<span class="type">String</span>, <span class="type">Double</span>)] &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">createAccumulator</span></span>(): (<span class="type">String</span>, <span class="type">Double</span>, <span class="type">Int</span>) = (<span class="string">&quot;&quot;</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">add</span></span>(value: (<span class="type">String</span>, <span class="type">Double</span>), accumulator: (<span class="type">String</span>, <span class="type">Double</span>, <span class="type">Int</span>)): (<span class="type">String</span>, <span class="type">Double</span>, <span class="type">Int</span>) = (value._1, accumulator._2 + value._2, accumulator._3 + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">getResult</span></span>(accumulator: (<span class="type">String</span>, <span class="type">Double</span>, <span class="type">Int</span>)): (<span class="type">String</span>, <span class="type">Double</span>) = (accumulator._1, accumulator._2 / accumulator._3)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">merge</span></span>(a: (<span class="type">String</span>, <span class="type">Double</span>, <span class="type">Int</span>), b: (<span class="type">String</span>, <span class="type">Double</span>, <span class="type">Int</span>)): (<span class="type">String</span>, <span class="type">Double</span>, <span class="type">Int</span>) = (a._1, a._2 + b._2, a._3 + b._3)</span><br><span class="line">      &#125;).print()</span><br><span class="line">    env.execute(<span class="type">Demo02SpeedAVG</span>.getClass.getName)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="1-3-2-全量聚合函数"><a href="#1-3-2-全量聚合函数" class="headerlink" title="1.3.2.全量聚合函数"></a>1.3.2.全量聚合函数</h5><h6 id="案例三-每隔10s对窗口内所有汽车的车速进行排序"><a href="#案例三-每隔10s对窗口内所有汽车的车速进行排序" class="headerlink" title="案例三:每隔10s对窗口内所有汽车的车速进行排序"></a>案例三:每隔10s对窗口内所有汽车的车速进行排序</h6><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xyz.window</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.lang3.<span class="type">StringUtils</span></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.common.serialization.<span class="type">SimpleStringSchema</span></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.scala.<span class="type">StreamExecutionEnvironment</span></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.scala._</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.scala.function.<span class="type">ProcessAllWindowFunction</span></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.windowing.assigners.<span class="type">TumblingProcessingTimeWindows</span></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.windowing.time.<span class="type">Time</span></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.windowing.windows.<span class="type">TimeWindow</span></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.connectors.kafka.<span class="type">FlinkKafkaConsumer</span></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.util.<span class="type">Collector</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.<span class="type">Properties</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 每隔10s对窗口内所有汽车的车速进行排序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Demo03SortSpeed</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> env = <span class="type">StreamExecutionEnvironment</span>.getExecutionEnvironment</span><br><span class="line">    env.setParallelism(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">val</span> props = <span class="keyword">new</span> <span class="type">Properties</span>()</span><br><span class="line">    props.setProperty(<span class="string">&quot;bootstrap.servers&quot;</span>, <span class="string">&quot;hadoop001:9092&quot;</span>)</span><br><span class="line">    props.setProperty(<span class="string">&quot;group.id&quot;</span>, <span class="string">&quot;StatisCarFlow&quot;</span>)</span><br><span class="line">    env.addSource(<span class="keyword">new</span> <span class="type">FlinkKafkaConsumer</span>[<span class="type">String</span>](<span class="string">&quot;traffic_info&quot;</span>, <span class="keyword">new</span> <span class="type">SimpleStringSchema</span>(), props).setStartFromEarliest())</span><br><span class="line">      .filter(line =&gt; <span class="type">StringUtils</span>.isNotEmpty(line) &amp;&amp; !line.equals(<span class="string">&quot;None&quot;</span>))</span><br><span class="line">      .map(line =&gt; &#123;</span><br><span class="line">        <span class="keyword">val</span> strings = line.split(<span class="string">&quot;,&quot;</span>)</span><br><span class="line">        (strings(<span class="number">1</span>), strings(<span class="number">4</span>).toDouble)</span><br><span class="line">      &#125;).windowAll(<span class="type">TumblingProcessingTimeWindows</span>.of(<span class="type">Time</span>.seconds(<span class="number">10</span>)))</span><br><span class="line">      <span class="comment">// 注意：想要全局排序并行度需要设置为1</span></span><br><span class="line">      .process(<span class="keyword">new</span> <span class="type">ProcessAllWindowFunction</span>[(<span class="type">String</span>, <span class="type">Double</span>), (<span class="type">String</span>, <span class="type">Double</span>), <span class="type">TimeWindow</span>] &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">process</span></span>(context: <span class="type">Context</span>, elements: <span class="type">Iterable</span>[(<span class="type">String</span>, <span class="type">Double</span>)], out: <span class="type">Collector</span>[(<span class="type">String</span>, <span class="type">Double</span>)]): <span class="type">Unit</span> = &#123;</span><br><span class="line">          <span class="keyword">val</span> list = elements.toList.sortBy(_._2)</span><br><span class="line">          <span class="keyword">for</span> (ele &lt;- list) &#123;</span><br><span class="line">            out.collect(ele._1, ele._2)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;).print()</span><br><span class="line">    env.execute(<span class="type">Demo03SortSpeed</span>.getClass.getName)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h6 id="案例四-每隔10s统计出窗口内所有车辆的最大及最小速度"><a href="#案例四-每隔10s统计出窗口内所有车辆的最大及最小速度" class="headerlink" title="案例四:每隔10s统计出窗口内所有车辆的最大及最小速度"></a>案例四:每隔10s统计出窗口内所有车辆的最大及最小速度</h6><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xyz.window</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.lang3.<span class="type">StringUtils</span></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.common.serialization.<span class="type">SimpleStringSchema</span></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.scala.<span class="type">StreamExecutionEnvironment</span></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.scala._</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.scala.function.<span class="type">ProcessAllWindowFunction</span></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.windowing.assigners.<span class="type">TumblingProcessingTimeWindows</span></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.windowing.time.<span class="type">Time</span></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.windowing.windows.<span class="type">TimeWindow</span></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.connectors.kafka.<span class="type">FlinkKafkaConsumer</span></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.util.<span class="type">Collector</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.<span class="type">Properties</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 每隔10s统计出窗口内所有车辆的最大及最小速度</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Demo04MaxMinSpeed</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> env = <span class="type">StreamExecutionEnvironment</span>.getExecutionEnvironment</span><br><span class="line">    env.setParallelism(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">val</span> props = <span class="keyword">new</span> <span class="type">Properties</span>()</span><br><span class="line">    props.setProperty(<span class="string">&quot;bootstrap.servers&quot;</span>, <span class="string">&quot;hadoop001:9092&quot;</span>)</span><br><span class="line">    props.setProperty(<span class="string">&quot;group.id&quot;</span>, <span class="string">&quot;StatisCarFlow&quot;</span>)</span><br><span class="line">    env.addSource(<span class="keyword">new</span> <span class="type">FlinkKafkaConsumer</span>[<span class="type">String</span>](<span class="string">&quot;traffic_info&quot;</span>, <span class="keyword">new</span> <span class="type">SimpleStringSchema</span>(), props).setStartFromEarliest())</span><br><span class="line">      .filter(line =&gt; <span class="type">StringUtils</span>.isNotEmpty(line) &amp;&amp; !line.equals(<span class="string">&quot;None&quot;</span>))</span><br><span class="line">      .map(line =&gt; &#123;</span><br><span class="line">        <span class="keyword">val</span> strings = line.split(<span class="string">&quot;,&quot;</span>)</span><br><span class="line">        (strings(<span class="number">1</span>), strings(<span class="number">4</span>).toDouble)</span><br><span class="line">      &#125;</span><br><span class="line">      ).windowAll(<span class="type">TumblingProcessingTimeWindows</span>.of(<span class="type">Time</span>.seconds(<span class="number">10</span>)))</span><br><span class="line">      .process(<span class="keyword">new</span> <span class="type">ProcessAllWindowFunction</span>[(<span class="type">String</span>, <span class="type">Double</span>), <span class="type">String</span>, <span class="type">TimeWindow</span>] &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">process</span></span>(context: <span class="type">Context</span>, elements: <span class="type">Iterable</span>[(<span class="type">String</span>, <span class="type">Double</span>)], out: <span class="type">Collector</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">          <span class="keyword">val</span> list = elements.toList.sortBy(_._2)</span><br><span class="line">          <span class="keyword">val</span> minSpeed = list.head</span><br><span class="line">          <span class="keyword">val</span> maxSpeed = list.last</span><br><span class="line">          <span class="keyword">val</span> startWindowTime = context.window.getStart</span><br><span class="line">          <span class="keyword">val</span> endWindowTime = context.window.getEnd</span><br><span class="line">          out.collect(<span class="string">s&quot;minSpeed:<span class="subst">$minSpeed</span>,maxSpeed:<span class="subst">$maxSpeed</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;).print()</span><br><span class="line"></span><br><span class="line">    env.execute(<span class="type">Demo04MaxMinSpeed</span>.getClass.getName)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="1-4-Flink-Time时间语义"><a href="#1-4-Flink-Time时间语义" class="headerlink" title="1.4.Flink Time时间语义"></a>1.4.Flink Time时间语义</h4><p>Flink定义了三类时间</p>
<ul>
<li>处理时间（Process Time）数据进入Flink被处理的系统时间（Operator处理数据的系统时间）</li>
<li>事件时间（Event Time）数据在数据源产生的时间，一般由事件中的时间戳描述，比如用户日志中的TimeStamp</li>
<li>摄取时间（Ingestion Time）数据进入Flink的时间，记录被Source节点观察到的系统时间</li>
</ul>
<p><img src="/img%5Cimage-20211025150546185.png" alt="image-20211025150546185"></p>
<p>Flink流式计算的时候需要显示定义时间语义，根据不同的时间语义来处理数据，比如指定的时间语义是</p>
<p>事件时间，那么我们就要切换到事件时间的世界观中，窗口的起始与终止时间都是以事件时间为依据</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置时间语义为Ingestion Time </span></span><br><span class="line">env.setStreamTimeCharacteristic(<span class="type">TimeCharacteristic</span>.<span class="type">IngestionTime</span>)</span><br><span class="line"><span class="comment">// 设置时间语义为Event Time 我们还需要指定一下数据中哪个字段是事件时间</span></span><br><span class="line">env.setStreamTimeCharacteristic(<span class="type">TimeCharacteristic</span>.<span class="type">EventTime</span>)</span><br></pre></td></tr></table></figure>

<h5 id="1-4-1-基于事件时间的Window操作"><a href="#1-4-1-基于事件时间的Window操作" class="headerlink" title="1.4.1.基于事件时间的Window操作"></a>1.4.1.基于事件时间的Window操作</h5><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xyz.window.eventtime</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.scala.<span class="type">StreamExecutionEnvironment</span></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.scala._</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.windowing.assigners.<span class="type">TumblingEventTimeWindows</span></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.windowing.time.<span class="type">Time</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 基于事件时间的Window操作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">EventTimeWindow</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> env = <span class="type">StreamExecutionEnvironment</span>.getExecutionEnvironment</span><br><span class="line">    <span class="comment">// flink1.12版本后默认的为EventTime</span></span><br><span class="line">    <span class="comment">//    env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime)</span></span><br><span class="line">    <span class="keyword">val</span> source = env.socketTextStream(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">9527</span>)</span><br><span class="line">    source.assignAscendingTimestamps(data =&gt; &#123;</span><br><span class="line">      data.split(<span class="string">&quot;,&quot;</span>)(<span class="number">0</span>).toLong</span><br><span class="line">    &#125;)</span><br><span class="line">      .flatMap(x =&gt; x.split(<span class="string">&quot;,&quot;</span>).tail).map((_, <span class="number">1</span>)).keyBy(_._1)</span><br><span class="line">      .window(<span class="type">TumblingEventTimeWindows</span>.of(<span class="type">Time</span>.seconds(<span class="number">10</span>)))</span><br><span class="line">      .reduce((v1: (<span class="type">String</span>, <span class="type">Int</span>), v2: (<span class="type">String</span>, <span class="type">Int</span>)) =&gt; &#123;</span><br><span class="line">        (v1._1, v1._2 + v2._2)</span><br><span class="line">      &#125;)</span><br><span class="line">      .print()</span><br><span class="line">    env.execute(<span class="type">EventTimeWindow</span>.getClass.getName)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="1-5-Watermark"><a href="#1-5-Watermark" class="headerlink" title="1.5. Watermark"></a>1.5. Watermark</h4><h5 id="1-5-1-Watermark介绍"><a href="#1-5-1-Watermark介绍" class="headerlink" title="1.5.1. Watermark介绍"></a>1.5.1. Watermark介绍</h5><p>官网地址:</p>
<p><a target="_blank" rel="noopener" href="https://ci.apache.org/projects/flink/flink-docs-release-1.12/dev/event_timestamps_watermarks.html#writing-a-periodic-watermarkgenerator">https://ci.apache.org/projects/flink/flink-docs-release-1.12/dev/event_timestamps_watermarks.html#writing-a-periodic-watermarkgenerator</a></p>
<p>Watermark本质就是时间戳,在使用Flink处理数据的时候，数据通常都是按照事件产生的时间（事件时间）的顺序进入到Flink，但是在遇到特殊情况下，比如遇到网络延迟或者使用Kafka（多分区） 很难保证数据都是按照事件时间的顺序进入Flink，很有可能是乱序进入。</p>
<p>如果使用的是事件时间这个语义，数据一旦是乱序进入，那么在使用Window处理数据的时候，就会出现延迟数据不会被计算的问题</p>
<p><img src="/img%5Cimage-20211027092324003.png" alt="image-20211027092324003"></p>
<p><img src="/img%5Cimage-20211027092703537.png" alt="image-20211027092703537"></p>
<p>举例： Window窗口长度10s，滚动窗口</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">001 zs 2020-04-25 10:00:01</span><br><span class="line">001 zs 2020-04-25 10:00:02</span><br><span class="line">001 zs 2020-04-25 10:00:03</span><br><span class="line">001 zs 2020-04-25 10:00:11 窗口触发执行</span><br><span class="line">001 zs 2020-04-25 10:00:05 延迟数据，不会被上一个窗口所计算导致计算结果不正确</span><br></pre></td></tr></table></figure>

<p>Watermark+Window可以很好的解决延迟数据的问题</p>
<p>Flink窗口计算的过程中，如果数据全部到达就会到窗口中的数据做处理，如果有延迟数据，那么窗口需要等待全部的数据到来之后，再触发窗口执行，需要等待多久？不可能无限期等待，我们用户可以自己来设置延迟时间这样就可以<strong>尽可能</strong>保证延迟数据被处理</p>
<p>根据用户指定的延迟时间生成水印（Watermak = 最大事件时间-指定延迟时间）</p>
<p>当Watermak 大于等于窗口的停止时间，这个窗口就会被触发执行</p>
<p>举例：Window窗口长度10s(01-10)，滚动窗口，指定延迟时间3s</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">001</span> ls <span class="number">2020</span><span class="number">-04</span><span class="number">-25</span> <span class="number">10</span>:<span class="number">00</span>:<span class="number">01</span> wm:<span class="number">2020</span><span class="number">-04</span><span class="number">-25</span> <span class="number">09</span>:<span class="number">59</span>:<span class="number">58</span></span><br><span class="line">env.setStreamTimeCharacteristic(<span class="type">TimeCharacteristic</span>.<span class="type">EventTime</span>) </span><br><span class="line"><span class="keyword">val</span> stream = env.socketTextStream(<span class="string">&quot;node01&quot;</span>, <span class="number">8888</span>).assignAscendingTimestamps(data =&gt; &#123; </span><br><span class="line"><span class="keyword">val</span> splits = data.split(<span class="string">&quot; &quot;</span>) </span><br><span class="line">splits(<span class="number">0</span>).toLong </span><br><span class="line">&#125;)</span><br><span class="line">stream .flatMap(x=&gt;x.split(<span class="string">&quot; &quot;</span>).tail) .map((_, <span class="number">1</span>)) .keyBy(_._1) </span><br><span class="line"><span class="comment">// .timeWindow(Time.seconds(10)) </span></span><br><span class="line">.window(<span class="type">TumblingEventTimeWindows</span>.of(<span class="type">Time</span>.seconds(<span class="number">10</span>))) </span><br><span class="line">.reduce((v1: (<span class="type">String</span>, <span class="type">Int</span>), v2: (<span class="type">String</span>, <span class="type">Int</span>)) =&gt; &#123; </span><br><span class="line">(v1._1, v1._2 + v2._2) </span><br><span class="line">&#125;).print() </span><br><span class="line">env.execute() </span><br><span class="line">&#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">001</span> ls <span class="number">2020</span><span class="number">-04</span><span class="number">-25</span> <span class="number">10</span>:<span class="number">00</span>:<span class="number">02</span> wm:<span class="number">2020</span><span class="number">-04</span><span class="number">-25</span> <span class="number">09</span>:<span class="number">59</span>:<span class="number">59</span></span><br><span class="line"><span class="number">001</span> ls <span class="number">2020</span><span class="number">-04</span><span class="number">-25</span> <span class="number">10</span>:<span class="number">00</span>:<span class="number">03</span> wm:<span class="number">2020</span><span class="number">-04</span><span class="number">-25</span> <span class="number">10</span>:<span class="number">00</span>:<span class="number">00</span></span><br><span class="line"><span class="number">001</span> ls <span class="number">2020</span><span class="number">-04</span><span class="number">-25</span> <span class="number">10</span>:<span class="number">00</span>:<span class="number">09</span> wm:<span class="number">2020</span><span class="number">-04</span><span class="number">-25</span> <span class="number">10</span>:<span class="number">00</span>:<span class="number">06</span></span><br><span class="line"><span class="number">001</span> ls <span class="number">2020</span><span class="number">-04</span><span class="number">-25</span> <span class="number">10</span>:<span class="number">00</span>:<span class="number">12</span> wm:<span class="number">2020</span><span class="number">-04</span><span class="number">-25</span> <span class="number">10</span>:<span class="number">00</span>:<span class="number">09</span></span><br><span class="line"><span class="number">001</span> ls <span class="number">2020</span><span class="number">-04</span><span class="number">-25</span> <span class="number">10</span>:<span class="number">00</span>:<span class="number">08</span> wm:<span class="number">2020</span><span class="number">-04</span><span class="number">-25</span> <span class="number">10</span>:<span class="number">00</span>:<span class="number">05</span> 延迟数据</span><br><span class="line"><span class="number">001</span> ls <span class="number">2020</span><span class="number">-04</span><span class="number">-25</span> <span class="number">10</span>:<span class="number">00</span>:<span class="number">13</span> wm:<span class="number">2020</span><span class="number">-04</span><span class="number">-25</span> <span class="number">10</span>:<span class="number">00</span>:<span class="number">10</span> 此时wm &gt;= window end time 触发窗口</span><br><span class="line">执行 处理的是事件时间<span class="number">01</span><span class="number">-10</span>的数据，并不是水印时间为<span class="number">01</span><span class="number">-10</span>的数据 **重点**</span><br><span class="line">讲道理，如果没有<span class="type">Watermark</span>在倒数第三条数据来的时候，就会触发执行，那么倒数第二条的延迟数据</span><br><span class="line">就不会被计算，那么有了水印可以处理延迟<span class="number">3</span>s内的数据</span><br></pre></td></tr></table></figure>

<p>注意：如果数据不会乱序进入Flink，没必要使用Watermark</p>
<p>代码演示</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xyz.window.watermark</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.xyz.window.eventtime.<span class="type">EventTimeWindow</span></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.functions.timestamps.<span class="type">BoundedOutOfOrdernessTimestampExtractor</span></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.scala.<span class="type">StreamExecutionEnvironment</span></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.scala._</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.windowing.assigners.<span class="type">TumblingEventTimeWindows</span></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.windowing.time.<span class="type">Time</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * WatermarkDemo1</span></span><br><span class="line"><span class="comment"> * 测试数据</span></span><br><span class="line"><span class="comment">10000,hello,msb</span></span><br><span class="line"><span class="comment">14000,hello,flink</span></span><br><span class="line"><span class="comment">20000,hello,hadoop</span></span><br><span class="line"><span class="comment">21000,hello,bj</span></span><br><span class="line"><span class="comment">17000,hello,sh</span></span><br><span class="line"><span class="comment">23000,hello,jjj</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">WatermarkDemo1</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> env = <span class="type">StreamExecutionEnvironment</span>.getExecutionEnvironment</span><br><span class="line">    <span class="comment">// flink1.12版本后默认的为EventTime</span></span><br><span class="line">    <span class="comment">//    env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime)</span></span><br><span class="line">    <span class="keyword">val</span> source = env.socketTextStream(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">9527</span>)</span><br><span class="line">    source.assignTimestampsAndWatermarks(<span class="keyword">new</span> <span class="type">BoundedOutOfOrdernessTimestampExtractor</span>[<span class="type">String</span>](<span class="type">Time</span>.seconds(<span class="number">2</span>)) &#123;</span><br><span class="line">      <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">extractTimestamp</span></span>(element: <span class="type">String</span>): <span class="type">Long</span> = &#123;</span><br><span class="line">        element.split(<span class="string">&quot;,&quot;</span>)(<span class="number">0</span>).toLong</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">      .flatMap(x =&gt; x.split(<span class="string">&quot;,&quot;</span>).tail).map((_, <span class="number">1</span>)).keyBy(_._1)</span><br><span class="line">      .window(<span class="type">TumblingEventTimeWindows</span>.of(<span class="type">Time</span>.seconds(<span class="number">10</span>)))</span><br><span class="line">      .reduce((v1: (<span class="type">String</span>, <span class="type">Int</span>), v2: (<span class="type">String</span>, <span class="type">Int</span>)) =&gt; &#123;</span><br><span class="line">        (v1._1, v1._2 + v2._2)</span><br><span class="line">      &#125;)</span><br><span class="line">      .print()</span><br><span class="line">    env.execute(<span class="type">WatermarkDemo1</span>.getClass.getName)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="1-5-2-Watermark生产策略"><a href="#1-5-2-Watermark生产策略" class="headerlink" title="1.5.2. Watermark生产策略"></a>1.5.2. Watermark生产策略</h5><h6 id="周期性水印（Periodic-Watermark）"><a href="#周期性水印（Periodic-Watermark）" class="headerlink" title="周期性水印（Periodic Watermark）"></a>周期性水印（Periodic Watermark）</h6><p>根据事件或者处理时间周期性的触发水印生成器(Assigner)，默认100ms，每隔100毫秒自动向流里注入一个Watermark</p>
<p>代码案例一:</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xyz.window.watermark</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.functions.timestamps.<span class="type">BoundedOutOfOrdernessTimestampExtractor</span></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.scala.<span class="type">StreamExecutionEnvironment</span></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.scala._</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.windowing.assigners.<span class="type">TumblingEventTimeWindows</span></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.windowing.time.<span class="type">Time</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 周期性水印（Periodic Watermark）根据事件或者处理时间周期性的触发水印生成器(Assigner)</span></span><br><span class="line"><span class="comment"> * 默认100ms，每隔100毫秒自动向流里注入一个Watermark周期性水印API</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">PeriodicWatermarkDemo1</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> env = <span class="type">StreamExecutionEnvironment</span>.getExecutionEnvironment</span><br><span class="line">    <span class="comment">// flink1.12版本后默认的为EventTime</span></span><br><span class="line">    <span class="comment">//    env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime)</span></span><br><span class="line">    env.getConfig.setAutoWatermarkInterval(<span class="number">100</span>)</span><br><span class="line">    <span class="keyword">val</span> source = env.socketTextStream(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">9527</span>)</span><br><span class="line">    source.assignTimestampsAndWatermarks(<span class="keyword">new</span> <span class="type">BoundedOutOfOrdernessTimestampExtractor</span>[<span class="type">String</span>](<span class="type">Time</span>.seconds(<span class="number">2</span>)) &#123;</span><br><span class="line">      <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">extractTimestamp</span></span>(element: <span class="type">String</span>): <span class="type">Long</span> = &#123;</span><br><span class="line">        element.split(<span class="string">&quot;,&quot;</span>)(<span class="number">0</span>).toLong</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">      .flatMap(x =&gt; x.split(<span class="string">&quot;,&quot;</span>).tail).map((_, <span class="number">1</span>)).keyBy(_._1)</span><br><span class="line">      .window(<span class="type">TumblingEventTimeWindows</span>.of(<span class="type">Time</span>.seconds(<span class="number">10</span>)))</span><br><span class="line">      .reduce((v1: (<span class="type">String</span>, <span class="type">Int</span>), v2: (<span class="type">String</span>, <span class="type">Int</span>)) =&gt; &#123;</span><br><span class="line">        (v1._1, v1._2 + v2._2)</span><br><span class="line">      &#125;)</span><br><span class="line">      .print()</span><br><span class="line">    env.execute(<span class="type">PeriodicWatermarkDemo1</span>.getClass.getName)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码案例二:</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xyz.window.watermark</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.functions.<span class="type">AssignerWithPeriodicWatermarks</span></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.scala._</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.watermark.<span class="type">Watermark</span></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.windowing.assigners.<span class="type">TumblingEventTimeWindows</span></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.windowing.time.<span class="type">Time</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 周期性水印自定义生成</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">PeriodicWatermarkDemo2</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> env = <span class="type">StreamExecutionEnvironment</span>.getExecutionEnvironment</span><br><span class="line">    <span class="comment">// flink1.12版本后默认的为EventTime</span></span><br><span class="line">    <span class="comment">//    env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime)</span></span><br><span class="line">    env.getConfig.setAutoWatermarkInterval(<span class="number">100</span>)</span><br><span class="line">    <span class="keyword">val</span> source = env.socketTextStream(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">9527</span>)</span><br><span class="line">    source.assignTimestampsAndWatermarks(<span class="keyword">new</span> <span class="type">MyTimestampAndWatermarks</span>(<span class="number">3000</span>))</span><br><span class="line">      .flatMap(x =&gt; x.split(<span class="string">&quot;,&quot;</span>).tail).map((_, <span class="number">1</span>)).keyBy(_._1)</span><br><span class="line">      .window(<span class="type">TumblingEventTimeWindows</span>.of(<span class="type">Time</span>.seconds(<span class="number">10</span>)))</span><br><span class="line">      .reduce((v1: (<span class="type">String</span>, <span class="type">Int</span>), v2: (<span class="type">String</span>, <span class="type">Int</span>)) =&gt; &#123;</span><br><span class="line">        (v1._1, v1._2 + v2._2)</span><br><span class="line">      &#125;)</span><br><span class="line">      .print()</span><br><span class="line">    env.execute(<span class="type">PeriodicWatermarkDemo2</span>.getClass.getName)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">MyTimestampAndWatermarks</span>(<span class="params">delayTime: <span class="type">Long</span></span>) <span class="keyword">extends</span> <span class="title">AssignerWithPeriodicWatermarks</span>[<span class="type">String</span>] </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> maxCurrentWatermark: <span class="type">Long</span> = _</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 水印=最大事件时间-延迟时间 后被调用 水印是递增，小于上一个水印不会被发射出去</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">getCurrentWatermark</span></span>: <span class="type">Watermark</span> = &#123;</span><br><span class="line">      <span class="comment">// 产生水印</span></span><br><span class="line">      <span class="keyword">new</span> <span class="type">Watermark</span>(maxCurrentWatermark - delayTime)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取当前的时间戳 先被调用</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">extractTimestamp</span></span>(element: <span class="type">String</span>, recordTimestamp: <span class="type">Long</span>): <span class="type">Long</span> = &#123;</span><br><span class="line">      <span class="keyword">val</span> currentTimeStamp = element.split(<span class="string">&quot;,&quot;</span>)(<span class="number">0</span>).toLong</span><br><span class="line">      maxCurrentWatermark = math.max(currentTimeStamp, maxCurrentWatermark)</span><br><span class="line">      currentTimeStamp</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="间歇性水印（Punctuated-Watermark）"><a href="#间歇性水印（Punctuated-Watermark）" class="headerlink" title="间歇性水印（Punctuated Watermark）"></a>间歇性水印（Punctuated Watermark）</h6><p>在观察到事件后，会依据用户指定的条件来决定是否发射水印</p>
<p>比如，在车流量的数据中，001卡口通信经常异常，传回到服务器的数据会有延迟问题，其他的卡口都是正常的，那么这个卡口的数据需要打上水印</p>
<p>代码案例三:</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xyz.window.watermark</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.common.functions.<span class="type">ReduceFunction</span></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.functions.<span class="type">AssignerWithPunctuatedWatermarks</span></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.scala.<span class="type">StreamExecutionEnvironment</span></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.scala._</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.watermark.<span class="type">Watermark</span></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.windowing.assigners.<span class="type">TumblingEventTimeWindows</span></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.windowing.time.<span class="type">Time</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">001,10000</span></span><br><span class="line"><span class="comment">002,14000</span></span><br><span class="line"><span class="comment">002,20000</span></span><br><span class="line"><span class="comment">002,21000</span></span><br><span class="line"><span class="comment">001,17000</span></span><br><span class="line"><span class="comment">002,23000</span></span><br><span class="line"><span class="comment">001,23000</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">PunctuatedWatermarkDemo1</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> env = <span class="type">StreamExecutionEnvironment</span>.getExecutionEnvironment</span><br><span class="line">    env.setParallelism(<span class="number">1</span>)</span><br><span class="line">    <span class="comment">// flink1.12版本后默认的为EventTime</span></span><br><span class="line">    <span class="comment">//    env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime)</span></span><br><span class="line">    env.getConfig.setAutoWatermarkInterval(<span class="number">100</span>)</span><br><span class="line">    <span class="keyword">val</span> source = env.socketTextStream(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">9527</span>)</span><br><span class="line">    source.map(line =&gt; &#123;</span><br><span class="line">      <span class="keyword">val</span> arr = line.split(<span class="string">&quot;,&quot;</span>)</span><br><span class="line">      (arr(<span class="number">0</span>), arr(<span class="number">1</span>).toLong)</span><br><span class="line">    &#125;)</span><br><span class="line">      .assignTimestampsAndWatermarks(<span class="keyword">new</span> myWatermark(<span class="number">3000</span>))</span><br><span class="line">      .map(value =&gt; &#123;</span><br><span class="line">        (value._1, <span class="number">1</span>)</span><br><span class="line">      &#125;)</span><br><span class="line">      .keyBy(_._1).window(<span class="type">TumblingEventTimeWindows</span>.of(<span class="type">Time</span>.seconds(<span class="number">10</span>)))</span><br><span class="line">      .reduce(<span class="keyword">new</span> <span class="type">ReduceFunction</span>[(<span class="type">String</span>, <span class="type">Int</span>)] &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">reduce</span></span>(value1: (<span class="type">String</span>, <span class="type">Int</span>), value2: (<span class="type">String</span>, <span class="type">Int</span>)): (<span class="type">String</span>, <span class="type">Int</span>) = (value1._1, value1._2 + value2._2)</span><br><span class="line">      &#125;)</span><br><span class="line"></span><br><span class="line">      .print()</span><br><span class="line">    env.execute(<span class="type">PunctuatedWatermarkDemo1</span>.getClass.getName)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">myWatermark</span>(<span class="params">delay: <span class="type">Long</span></span>) <span class="keyword">extends</span> <span class="title">AssignerWithPunctuatedWatermarks</span>[(<span class="type">String</span>, <span class="type">Long</span>)] </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> maxTimeStamp: <span class="type">Long</span> = _</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">checkAndGetNextWatermark</span></span>(elem: (<span class="type">String</span>, <span class="type">Long</span>), extractedTimestamp: <span class="type">Long</span>): <span class="type">Watermark</span> = &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="string">&quot;001&quot;</span>.equals(elem._1)) &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="type">Watermark</span>(maxTimeStamp - delay)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="literal">null</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">extractTimestamp</span></span>(element: (<span class="type">String</span>, <span class="type">Long</span>), previousElementTimestamp: <span class="type">Long</span>): <span class="type">Long</span> = &#123;</span><br><span class="line">      maxTimeStamp = math.max(element._2, maxTimeStamp)</span><br><span class="line">      element._2</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="1-6-AllowedLateness"><a href="#1-6-AllowedLateness" class="headerlink" title="1.6.AllowedLateness"></a>1.6.AllowedLateness</h4><p>基于Event-Time的窗口处理流式数据，虽然提供了Watermark机制，却只能在一定程度上解决了数据乱序的问题。但在某些情况下数据可能延时会非常严重，即使通过Watermark机制也无法等到数据全部进入窗口再进行处理。Flink中默认会将这些迟到的数据做丢弃处理，但是有些时候用户希望即使数据延迟并不是很严重的情况下，也能继续窗口计算，不希望对于数据延迟比较严重的数据混入正常的计算流程中，此时就需要使用Allowed Lateness机制来对迟到的数据进行额外的处理。</p>
<p>举例：例如用户大屏数据展示系统，即使正常的窗口中没有将迟到的数据进行统计，但为了保证页面数据显示的连续性，后来接入到系统中迟到比较严重的数据所统计出来的结果不希望显示在屏幕上，而是将延时数据和结果存储到数据库中，便于后期对延时数据进行分析。对于这种情况需要借助Side Output来处理，通过使用sideOutputLateData（OutputTag）来标记迟到数据计算的结果，然后使用getSideOutput（lateOutputTag）从窗口结果中获取lateOutputTag标签对应的数据，之后转成独立的DataStream数据集进行处理，创建late-data的OutputTag，再通过该标签从窗口结果中将迟到数据筛选出来</p>
<p>Flink默认当窗口计算完毕后，窗口元素数据及状态会被清空，但是使用AllowedLateness，可以延迟清除窗口元素数据及状态，以便于当延迟数据到来的时候，能够重新计算当前窗口</p>
<p>代码案例</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xyz.window.sideoutput</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.<span class="type">TimeCharacteristic</span></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.functions.timestamps.<span class="type">BoundedOutOfOrdernessTimestampExtractor</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.scala.<span class="type">StreamExecutionEnvironment</span></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.scala._</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.scala.function.<span class="type">ProcessAllWindowFunction</span></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.windowing.time.<span class="type">Time</span></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.windowing.windows.<span class="type">TimeWindow</span></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.util.<span class="type">Collector</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 问题1：使用AllowedLateness 方法是不是会降低flink计算的吞吐量？ 是的</span></span><br><span class="line"><span class="comment"> * 问题2：直接watermark设置为5 不是也可以代替这一通操作嘛？ 不能代替，watermark设置为5的</span></span><br><span class="line"><span class="comment"> * 话，允许延迟5s，每次处理过去5s的窗口数据，延迟比较高，如果使用这通操作，每次处理过去2s的数</span></span><br><span class="line"><span class="comment"> * 据，实时性比较高，当有新的延迟数据，即时计算，对于计算实时性比较高的场景还得使用这一通操作</span></span><br><span class="line"><span class="comment"> * 问题3：watermark（5s）+滑动窗口（滑动间隔2s）能够实现这通计算？ 不行</span></span><br><span class="line"><span class="comment"> * 案例：每隔5s统计各个卡口最近5s的车流量（滑动窗口），计算实时性小于2（ps：当10s的数据来</span></span><br><span class="line"><span class="comment"> * 了，8s之前的数据必须处理完），允许数据延迟5s，数据延迟超过5s的数据放入到侧输出流中</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 10000 hello</span></span><br><span class="line"><span class="comment"> * 11000 spark</span></span><br><span class="line"><span class="comment"> * 14000 flink</span></span><br><span class="line"><span class="comment"> * 15000 hadoop 此时窗口并不会计算，因为Watermark设为2s 此时的watermark是13000 窗口范围 10000-15000</span></span><br><span class="line"><span class="comment"> * 17000 sqoop 此时窗口会被计算 默认：窗口计算完毕，窗口数据全部会被清空</span></span><br><span class="line"><span class="comment"> * 12000 flume 此时窗口重新计算（10000-15000），因为开启了AllowedLateness 3s，当 watermark&gt;=window end+ AllowedLateness 3s 窗口数据及状态才会被清除掉，</span></span><br><span class="line"><span class="comment"> * 此时的watermark 是15000 20000 scala 此时上一个窗口（10000-15000）的数据及状态会被清空 12000 hdfs 此时窗口不会重新计算</span></span><br><span class="line"><span class="comment"> * 因为现在watermark是18000&gt;=15000+3000,12000数据是迟到 非常严重的数据，会被放入到侧输出流中</span></span><br><span class="line"><span class="comment"> * 本来10000-15000的窗口，在15000的时候会计算，但是由于Watermark 的原因，等待了2s 17000的时 候才会计算，</span></span><br><span class="line"><span class="comment"> * 又因为AllowedLateness 3s的原因，10000-15000的窗口会被保存3s（注意这是 eventtime时间语义），直到20000出现，才会被删除，</span></span><br><span class="line"><span class="comment"> * 所以在20000没有出现之前，凡是事件时间在 10000-15000的数据都会重新进行窗口计算 超过5s的数据，称之为迟到非常严重的数据，放入到侧输出流 5s以内的数据，</span></span><br><span class="line"><span class="comment"> * 称之为迟到不严重的数据，窗口重新计算</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Allowlatest</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> env = <span class="type">StreamExecutionEnvironment</span>.getExecutionEnvironment</span><br><span class="line">    env.setStreamTimeCharacteristic(<span class="type">TimeCharacteristic</span>.<span class="type">EventTime</span>)</span><br><span class="line">    env.setParallelism(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">val</span> stream = env.socketTextStream(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">9527</span>)</span><br><span class="line">    <span class="keyword">val</span> lateTag = <span class="keyword">new</span> <span class="type">OutputTag</span>[(<span class="type">Long</span>, <span class="type">String</span>)](<span class="string">&quot;late&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> value = stream.map(x =&gt; &#123;</span><br><span class="line">      <span class="keyword">val</span> strings = x.split(<span class="string">&quot;,&quot;</span>)</span><br><span class="line">      (strings(<span class="number">0</span>).toLong, strings(<span class="number">1</span>))</span><br><span class="line">    &#125;).assignTimestampsAndWatermarks(<span class="keyword">new</span> <span class="type">BoundedOutOfOrdernessTimestampExtractor</span>[(<span class="type">Long</span>, <span class="type">String</span>)](<span class="type">Time</span>.seconds(<span class="number">2</span>)) &#123;</span><br><span class="line">      <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">extractTimestamp</span></span>(element: (<span class="type">Long</span>, <span class="type">String</span>)): <span class="type">Long</span> = element._1</span><br><span class="line">    &#125;).timeWindowAll(<span class="type">Time</span>.seconds(<span class="number">5</span>)).allowedLateness(<span class="type">Time</span>.seconds(<span class="number">3</span>)).sideOutputLateData(lateTag).process(<span class="keyword">new</span> <span class="type">ProcessAllWindowFunction</span>[(<span class="type">Long</span>, <span class="type">String</span>), (<span class="type">Long</span>, <span class="type">String</span>), <span class="type">TimeWindow</span>] &#123;</span><br><span class="line">      <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">process</span></span>(context: <span class="type">Context</span>, elements: <span class="type">Iterable</span>[(<span class="type">Long</span>, <span class="type">String</span>)], out: <span class="type">Collector</span>[(<span class="type">Long</span>, <span class="type">String</span>)]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        println(context.window.getStart + <span class="string">&quot;---&quot;</span> + context.window.getEnd)</span><br><span class="line">        <span class="keyword">for</span> (elem &lt;- elements) &#123;</span><br><span class="line">          out.collect(elem)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    value.print(<span class="string">&quot;main&quot;</span>)</span><br><span class="line">    value.getSideOutput(lateTag).print(<span class="string">&quot;late&quot;</span>)</span><br><span class="line">    env.execute()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="1-7-Flink关联维表实战"><a href="#1-7-Flink关联维表实战" class="headerlink" title="1.7.Flink关联维表实战"></a>1.7.Flink关联维表实战</h4><p>​    在Flink实际开发过程中，可能会遇到source 进来的数据，需要连接数据库里面的字段，再做后面的处理</p>
<p>比如，想要通过id获取对应的地区名字，这时候需要通过id查询地区维度表，获取具体的地区名对于不同的应用场景，关联维度表的方式不同</p>
<p>场景1：维度表信息基本不发生改变，或者发生改变的频率很低</p>
<p>实现方案：采用Flink提供的CachedFile</p>
<p>Flink提供了一个分布式缓存（CachedFile），类似于hadoop，可以使用户在并行函数中很方便的读取本地文件，并把它放在TaskManager节点中，防止task重复拉取。 此缓存的工作机制如下：</p>
<p>程序注册一个文件或者目录(本地或者远程文件系统，例如hdfs或者s3)，通过ExecutionEnvironment注册缓存文件并为它起一个名称。 当程序执行，Flink自动将文件或者目录复制到所有TaskManager节点的本地文件系统，仅会执行一次。用户可以通过这个指定的名称查找文件或者目录，然后从TaskManager节点的本地文件系统访问它</p>
<p>代码案例一</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xyz.dimensiontable</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.common.functions.<span class="type">RichMapFunction</span></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.configuration.<span class="type">Configuration</span></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.scala.&#123;<span class="type">StreamExecutionEnvironment</span>, _&#125;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.util.<span class="type">FileUtils</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> scala.collection.mutable</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">DimensionTableDemo1</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> env = <span class="type">StreamExecutionEnvironment</span>.getExecutionEnvironment</span><br><span class="line">    env.registerCachedFile(<span class="string">&quot;D:\\tmp\\text01.txt&quot;</span>, <span class="string">&quot;id2city&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> socketStream = env.socketTextStream(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">9527</span>)</span><br><span class="line">    <span class="keyword">val</span> stream = socketStream.map(_.toInt)</span><br><span class="line">    stream.map(<span class="keyword">new</span> <span class="type">RichMapFunction</span>[<span class="type">Int</span>, <span class="type">String</span>] &#123;</span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">val</span> id2CityMap = <span class="keyword">new</span> mutable.<span class="type">HashMap</span>[<span class="type">Int</span>, <span class="type">String</span>]()</span><br><span class="line"></span><br><span class="line">      <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">open</span></span>(parameters: <span class="type">Configuration</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="keyword">val</span> file = getRuntimeContext.getDistributedCache.getFile(<span class="string">&quot;id2city&quot;</span>)</span><br><span class="line">        <span class="keyword">val</span> str = <span class="type">FileUtils</span>.readFileUtf8(file)</span><br><span class="line">        <span class="keyword">val</span> strings = str.split(<span class="string">&quot;\r\n&quot;</span>)</span><br><span class="line">        <span class="keyword">for</span> (str &lt;- strings) &#123;</span><br><span class="line">          <span class="keyword">val</span> splits = str.split(<span class="string">&quot;,&quot;</span>)</span><br><span class="line">          <span class="keyword">val</span> id = splits(<span class="number">0</span>).toInt</span><br><span class="line">          <span class="keyword">val</span> city = splits(<span class="number">1</span>)</span><br><span class="line">          id2CityMap.put(id, city)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">map</span></span>(value: <span class="type">Int</span>): <span class="type">String</span> = &#123;</span><br><span class="line">        id2CityMap.getOrElse(value, <span class="string">&quot;not found city&quot;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;).print()</span><br><span class="line">    env.execute()</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在集群中查看对应TaskManager的log日志，发现注册的fifile会被拉取到各个TaskManager的工作目录区</p>
<p><img src="/img%5Cimage-20211027145131283.png" alt="image-20211027145131283"></p>
<p>代码案例二:对于维度表更新频率比较高并且对于查询维度表的实时性要求比较高</p>
<p>实现方案：使用定时器，定时加载外部配置文件或者数据库</p>
<p>注意此种方式key对应的value值只允许增加和修改,不允许删除(如果删除对应的是key删除前对应的value值)</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xyz.dimensiontable</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.common.functions.<span class="type">RichMapFunction</span></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.configuration.<span class="type">Configuration</span></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.scala.&#123;<span class="type">StreamExecutionEnvironment</span>, _&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.&#123;<span class="type">Timer</span>, <span class="type">TimerTask</span>&#125;</span><br><span class="line"><span class="keyword">import</span> scala.collection.mutable</span><br><span class="line"><span class="keyword">import</span> scala.io.<span class="type">Source</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">DimensionTableDemo2</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> env = <span class="type">StreamExecutionEnvironment</span>.getExecutionEnvironment</span><br><span class="line">    env.setParallelism(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">val</span> stream = env.socketTextStream(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">9527</span>)</span><br><span class="line">    stream.map(<span class="keyword">new</span> <span class="type">RichMapFunction</span>[<span class="type">String</span>, <span class="type">String</span>] &#123;</span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">val</span> map = <span class="keyword">new</span> mutable.<span class="type">HashMap</span>[<span class="type">String</span>, <span class="type">String</span>]()</span><br><span class="line"></span><br><span class="line">      <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">open</span></span>(parameters: <span class="type">Configuration</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">        println(<span class="string">&quot;init data ...&quot;</span>)</span><br><span class="line">        query()</span><br><span class="line">        <span class="keyword">val</span> timer = <span class="keyword">new</span> <span class="type">Timer</span>(<span class="literal">true</span>)</span><br><span class="line">        timer.schedule(<span class="keyword">new</span> <span class="type">TimerTask</span> &#123;</span><br><span class="line">          <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">run</span></span>(): <span class="type">Unit</span> = &#123;</span><br><span class="line">            query()</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">//1s后，每隔2s执行一次</span></span><br><span class="line">        &#125;, <span class="number">1000</span>, <span class="number">2000</span>)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">def</span> <span class="title">query</span></span>() = &#123;</span><br><span class="line">        <span class="keyword">val</span> source = <span class="type">Source</span>.fromFile(<span class="string">&quot;D:\\tmp\\text01.txt&quot;</span>, <span class="string">&quot;UTF-8&quot;</span>)</span><br><span class="line">        <span class="keyword">val</span> iterator = source.getLines()</span><br><span class="line">        <span class="keyword">for</span> (elem &lt;- iterator) &#123;</span><br><span class="line">          <span class="keyword">val</span> vs = elem.split(<span class="string">&quot;,&quot;</span>)</span><br><span class="line">          map.put(vs(<span class="number">0</span>), vs(<span class="number">1</span>))</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">map</span></span>(key: <span class="type">String</span>): <span class="type">String</span> = &#123;</span><br><span class="line">        map.getOrElse(key, <span class="string">&quot;not found city&quot;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;).print()</span><br><span class="line">    env.execute()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果维度信息在配置文件中存储，那么还有一个解决方案，就是使用readFile读取文件，因为这个方法可以检测内容是否发生改变</p>
<p>代码案例三：对于维度表更新频率高并且对于查询维度表的实时性要求高</p>
<p>实现方案：管理员在修改配置文件的时候，需要将更改的信息同步值Kafka配置Topic中，然后将kafka的配置流信息变成广播流，广播到业务流的各个线程中</p>
<p><img src="/img%5Cimage-20211027150523831.png" alt="image-20211027150523831"></p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xyz.dimensiontable</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.common.serialization.<span class="type">SimpleStringSchema</span></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.common.state.<span class="type">MapStateDescriptor</span></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.common.typeinfo.<span class="type">BasicTypeInfo</span></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.functions.co.<span class="type">BroadcastProcessFunction</span></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.scala.&#123;<span class="type">StreamExecutionEnvironment</span>, _&#125;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.connectors.kafka.<span class="type">FlinkKafkaConsumer</span></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.util.<span class="type">Collector</span></span><br><span class="line"><span class="keyword">import</span> org.apache.kafka.common.serialization.<span class="type">StringSerializer</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.<span class="type">Properties</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">DimensionTableDemo3</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> env = <span class="type">StreamExecutionEnvironment</span>.getExecutionEnvironment</span><br><span class="line">    <span class="comment">//设置连接kafka的配置信息</span></span><br><span class="line">    <span class="keyword">val</span> props = <span class="keyword">new</span> <span class="type">Properties</span>()</span><br><span class="line">    props.setProperty(<span class="string">&quot;bootstrap.servers&quot;</span>, <span class="string">&quot;hadoop001:9092&quot;</span>)</span><br><span class="line">    props.setProperty(<span class="string">&quot;group.id&quot;</span>, <span class="string">&quot;flink-kafka-001&quot;</span>)</span><br><span class="line">    props.setProperty(<span class="string">&quot;key.deserializer&quot;</span>, classOf[<span class="type">StringSerializer</span>].getName)</span><br><span class="line">    props.setProperty(<span class="string">&quot;value.deserializer&quot;</span>, classOf[<span class="type">StringSerializer</span>].getName)</span><br><span class="line">    <span class="keyword">val</span> consumer = <span class="keyword">new</span> <span class="type">FlinkKafkaConsumer</span>[<span class="type">String</span>](<span class="string">&quot;configure&quot;</span>, <span class="keyword">new</span> <span class="type">SimpleStringSchema</span>(), props)</span><br><span class="line">    <span class="comment">//从topic最开始的数据读取</span></span><br><span class="line">    <span class="comment">//consumer.setStartFromEarliest()</span></span><br><span class="line">    <span class="comment">// 从最新的数据开始读取</span></span><br><span class="line">    consumer.setStartFromLatest()</span><br><span class="line">    <span class="comment">//动态配置信息流</span></span><br><span class="line">    <span class="keyword">val</span> configureStream = env.addSource(consumer)</span><br><span class="line">    <span class="comment">//业务流</span></span><br><span class="line">    <span class="keyword">val</span> busStream = env.socketTextStream(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">9527</span>)</span><br><span class="line">    <span class="keyword">val</span> descriptor = <span class="keyword">new</span> <span class="type">MapStateDescriptor</span>[<span class="type">String</span>, <span class="type">String</span>](<span class="string">&quot;dynamicConfig&quot;</span>, <span class="type">BasicTypeInfo</span>.<span class="type">STRING_TYPE_INFO</span>, <span class="type">BasicTypeInfo</span>.<span class="type">STRING_TYPE_INFO</span>)</span><br><span class="line">    <span class="comment">//设置广播流的数据描述信息</span></span><br><span class="line">    <span class="keyword">val</span> broadcastStream = configureStream.broadcast(descriptor)</span><br><span class="line">    <span class="comment">//connect关联业务流与配置信息流，broadcastStream流中的数据会广播到下游的各个线程中</span></span><br><span class="line">    busStream.connect(broadcastStream).process(<span class="keyword">new</span> <span class="type">BroadcastProcessFunction</span>[<span class="type">String</span>, <span class="type">String</span>, <span class="type">String</span>] &#123;</span><br><span class="line">      <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">processElement</span></span>(line: <span class="type">String</span>, ctx: <span class="type">BroadcastProcessFunction</span>[<span class="type">String</span>, <span class="type">String</span>, <span class="type">String</span>]#<span class="type">ReadOnlyContext</span>, out: <span class="type">Collector</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="keyword">val</span> broadcast = ctx.getBroadcastState(descriptor)</span><br><span class="line">        <span class="keyword">val</span> city = broadcast.get(line)</span><br><span class="line">        <span class="keyword">if</span> (city == <span class="literal">null</span>) &#123;</span><br><span class="line">          out.collect(<span class="string">&quot;not found city&quot;</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          out.collect(city)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//kafka中配置流信息，写入到广播流中</span></span><br><span class="line">      <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">processBroadcastElement</span></span>(line: <span class="type">String</span>, ctx: <span class="type">BroadcastProcessFunction</span>[<span class="type">String</span>, <span class="type">String</span>, <span class="type">String</span>]#<span class="type">Context</span>, out: <span class="type">Collector</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="keyword">val</span> broadcast = ctx.getBroadcastState(descriptor)</span><br><span class="line">        <span class="comment">//kafka中的数据</span></span><br><span class="line">        <span class="keyword">val</span> elems = line.split(<span class="string">&quot;,&quot;</span>)</span><br><span class="line">        broadcast.put(elems(<span class="number">0</span>), elems(<span class="number">1</span>))</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;).print()</span><br><span class="line">    env.execute()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/01/01/Flink%E5%9F%BA%E7%A1%80-Window-Watermark/" data-id="ckvl093b10007t3ghe07udbm2" class="article-share-link">
        分享
      </a>
      
    </footer>

  </div>

  
  
<nav class="article-nav">
  
  <a href="/2020/11/07/%E5%88%9D%E8%AF%86Flink/" class="article-nav-link">
    <strong class="article-nav-caption">前一篇</strong>
    <div class="article-nav-title">
      
      初识Flink
      
    </div>
  </a>
  
  
  <a href="/2019/07/05/scala%E5%9F%BA%E7%A1%8002/" class="article-nav-link">
    <strong class="article-nav-caption">后一篇</strong>
    <div class="article-nav-title">scala基础02</div>
  </a>
  
</nav>

  

  
  
  
  

</article>
</section>
    <footer class="footer">
  <div class="outer">
    <div class="float-right">
      <ul class="list-inline">
  
  <li><i class="fe fe-smile-alt"></i> <span id="busuanzi_value_site_uv"></span></li>
  
  <li><i class="fe fe-bookmark"></i> <span id="busuanzi_value_page_pv"></span></li>
  
</ul>
    </div>
    <ul class="list-inline">
      <li>个人博客 &copy; 2021</li>
      
        <li>京ICP备17054916号-2</li>
      
      <li>Powered by <a href="http://hexo.io/" target="_blank">Hexo</a></li>
      <li>theme  <a target="_blank" rel="noopener" href="https://github.com/zhwangart/hexo-theme-ocean">Ocean</a></li>
    </ul>
  </div>
</footer>
  </main>
  <aside class="sidebar">
    <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/hexo.svg" alt="个人博客"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">Home</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">Archives</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/gallery">Gallery</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/about">About</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link nav-item-search" title="搜索">
        <i class="fe fe-search"></i>
        搜索
      </a>
    </li>
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      <div class="totop" id="totop">
  <i class="fe fe-rocket"></i>
</div>
    </li>
    <li class="nav-item">
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="fe fe-feed"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
  </aside>
  
<script src="/js/jquery-2.0.3.min.js"></script>


<script src="/js/jquery.justifiedGallery.min.js"></script>


<script src="/js/lazyload.min.js"></script>


<script src="/js/busuanzi-2.3.pure.min.js"></script>



<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/copybtn.js"></script>





<script src="/js/tocbot.min.js"></script>

<script>
  // Tocbot_v4.7.0  http://tscanlin.github.io/tocbot/
  tocbot.init({
    tocSelector: '.tocbot',
    contentSelector: '.article-entry',
    headingSelector: 'h1, h2, h3, h4, h5, h6',
    hasInnerContainers: true,
    scrollSmooth: true,
    positionFixedSelector: '.tocbot',
    positionFixedClass: 'is-position-fixed',
    fixedSidebarOffset: 'auto',
  });
</script>



<script src="/js/ocean.js"></script>

</body>

</html>